#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 2
    bytecblock 0x151f7c75 0x151f7c750000000000000000000000000000000000000000000000000000
    // smart_contracts/reti_reader/contract.algo.ts:19
    // export class RetiReader extends Contract {
    txn NumAppArgs
    bz main_adminOnly@14
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    pushbytess 0x84c4425a 0x24e00c80 0xbb882927 0xa62f1132 0xd85acb4c 0x3d3b8b4a 0xc20865f4 // method "getValidatorConfig(uint64,uint64[])(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)", method "getValidatorStates(uint64,uint64[])(uint16,uint64,uint64,uint64)", method "getPools(uint64,uint64[])(uint64,(uint64,uint16,uint64))", method "getNodePoolAssignments(uint64,uint64[])((uint64[3])[8])", method "getAllPoolInfo(uint64,uint64[])((uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64),(uint16,uint64,uint64,uint64),(uint64,uint16,uint64)[],((uint64[3])[8]))", method "getBlockTimestamps(uint64)uint64", method "getAlgodVersion(uint64[])byte[]"
    txna ApplicationArgs 0
    match getValidatorConfig getValidatorStates getPools getNodePoolAssignments getAllPoolInfo getBlockTimestamps getAlgodVersion
    err

main_adminOnly@14:
    // smart_contracts/reti_reader/contract.algo.ts:20
    // @baremethod({ allowActions: ["UpdateApplication", "DeleteApplication"] })
    intc_1 // 1
    txn OnCompletion
    shl
    pushint 48 // 48
    &
    txn ApplicationID
    &&
    assert // OnCompletion must be one of UpdateApplication, DeleteApplication && can only call when not creating
    // smart_contracts/reti_reader/contract.algo.ts:22
    // assert(Txn.sender === Global.creatorAddress);
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/reti_reader/contract.algo.ts:20
    // @baremethod({ allowActions: ["UpdateApplication", "DeleteApplication"] })
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getValidatorConfig[routing]() -> void:
getValidatorConfig:
    // smart_contracts/reti_reader/contract.algo.ts:25
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getValidatorConfig_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:27
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getValidatorConfig_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:28
    // log(encodeArc4(this.getRemoteValidatorConfig(registryAppId, validatorId)));
    dig 5
    swap
    callsub getRemoteValidatorConfig
    log
    intc_1 // 1
    +
    bury 1
    b getValidatorConfig_for_header@2

getValidatorConfig_after_for@5:
    // smart_contracts/reti_reader/contract.algo.ts:25
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes base32(CUPXY5IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    log
    intc_1 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getValidatorStates[routing]() -> void:
getValidatorStates:
    // smart_contracts/reti_reader/contract.algo.ts:63
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getValidatorStates_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:65
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getValidatorStates_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:66
    // log(encodeArc4(this.getRemoteValidatorState(registryAppId, validatorId)));
    dig 5
    swap
    callsub getRemoteValidatorState
    log
    intc_1 // 1
    +
    bury 1
    b getValidatorStates_for_header@2

getValidatorStates_after_for@5:
    // smart_contracts/reti_reader/contract.algo.ts:63
    // @abimethod({ readonly: true, onCreate: "allow" })
    bytec_1 // 0x151f7c750000000000000000000000000000000000000000000000000000
    log
    intc_1 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getPools[routing]() -> void:
getPools:
    intc_0 // 0
    pushbytes ""
    dupn 2
    // smart_contracts/reti_reader/contract.algo.ts:87
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getPools_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:90
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getPools_after_for@9
    dig 2
    extract 2 0
    dig 1
    intc_2 // 8
    *
    extract_uint64
    dup
    bury 6
    // smart_contracts/reti_reader/contract.algo.ts:91
    // const poolInfoArr = this.getRemotePoolInfo(registryAppId, validatorId);
    dig 4
    swap
    callsub getRemotePoolInfo
    dup
    bury 9
    // smart_contracts/reti_reader/contract.algo.ts:92
    // for (const poolInfo of clone(poolInfoArr)) {
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    bury 7
    intc_0 // 0
    bury 6

getPools_for_header@4:
    // smart_contracts/reti_reader/contract.algo.ts:92
    // for (const poolInfo of clone(poolInfoArr)) {
    dig 5
    dig 7
    <
    bz getPools_after_for@7
    dig 7
    extract 2 0
    dig 6
    dup
    cover 2
    pushint 18 // 18
    *
    pushint 18 // 18
    extract3 // on error: index access is out of bounds
    // smart_contracts/reti_reader/contract.algo.ts:93
    // log(encodeArc4({ validatorId, poolInfo }));
    dig 6
    itob
    swap
    concat
    log
    intc_1 // 1
    +
    bury 6
    b getPools_for_header@4

getPools_after_for@7:
    dup
    intc_1 // 1
    +
    bury 1
    b getPools_for_header@2

getPools_after_for@9:
    // smart_contracts/reti_reader/contract.algo.ts:87
    // @abimethod({ readonly: true, onCreate: "allow" })
    bytec_1 // 0x151f7c750000000000000000000000000000000000000000000000000000
    log
    intc_1 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getNodePoolAssignments[routing]() -> void:
getNodePoolAssignments:
    // smart_contracts/reti_reader/contract.algo.ts:118
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getNodePoolAssignments_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:120
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getNodePoolAssignments_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:121
    // log(encodeArc4(this.getRemoteNodePoolAssignments(registryAppId, validatorId)));
    dig 5
    swap
    callsub getRemoteNodePoolAssignments
    log
    intc_1 // 1
    +
    bury 1
    b getNodePoolAssignments_for_header@2

getNodePoolAssignments_after_for@5:
    // smart_contracts/reti_reader/contract.algo.ts:118
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes 0x151f7c75000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    log
    intc_1 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getAllPoolInfo[routing]() -> void:
getAllPoolInfo:
    // smart_contracts/reti_reader/contract.algo.ts:140
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getAllPoolInfo_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:142
    // for (const validatorId of validatorIds) {
    dup
    dig 2
    <
    bz getAllPoolInfo_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:145
    // const config = this.getRemoteValidatorConfig(registryAppId, validatorId);
    dig 5
    dup
    cover 2
    dig 1
    callsub getRemoteValidatorConfig
    // smart_contracts/reti_reader/contract.algo.ts:146
    // const state = this.getRemoteValidatorState(registryAppId, validatorId);
    dig 2
    dig 2
    callsub getRemoteValidatorState
    // smart_contracts/reti_reader/contract.algo.ts:147
    // const poolInfo = this.getRemotePoolInfo(registryAppId, validatorId);
    dig 3
    dig 3
    callsub getRemotePoolInfo
    // smart_contracts/reti_reader/contract.algo.ts:148
    // const nodeAssignment = this.getRemoteNodePoolAssignments(registryAppId, validatorId);
    uncover 4
    uncover 4
    callsub getRemoteNodePoolAssignments
    // smart_contracts/reti_reader/contract.algo.ts:150-155
    // const allPoolInfo: AllPoolInfo = {
    //   config: clone(config),
    //   state: clone(state),
    //   poolInfo: clone(poolInfo),
    //   nodeAssignment: clone(nodeAssignment),
    // };
    uncover 3
    uncover 3
    concat
    pushbytes 0x01ce
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/reti_reader/contract.algo.ts:156
    // log(encodeArc4(allPoolInfo));
    log
    intc_1 // 1
    +
    bury 1
    b getAllPoolInfo_for_header@2

getAllPoolInfo_after_for@5:
    // smart_contracts/reti_reader/contract.algo.ts:140
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes base32(CUPXY5IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADTQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    log
    intc_1 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getBlockTimestamps[routing]() -> void:
getBlockTimestamps:
    // smart_contracts/reti_reader/contract.algo.ts:167
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/reti_reader/contract.algo.ts:169
    // for (let round: uint64 = Txn.lastValid - num - 1; round < Txn.firstValid - 1; round++) {
    txn LastValid
    swap
    -
    intc_1 // 1
    -

getBlockTimestamps_while_top@2:
    // smart_contracts/reti_reader/contract.algo.ts:169
    // for (let round: uint64 = Txn.lastValid - num - 1; round < Txn.firstValid - 1; round++) {
    txn FirstValid
    intc_1 // 1
    -
    dig 1
    >
    bz getBlockTimestamps_after_while@4
    // smart_contracts/reti_reader/contract.algo.ts:170
    // log(op.Block.blkTimestamp(round));
    dupn 2
    block BlkTimestamp
    itob
    log
    // smart_contracts/reti_reader/contract.algo.ts:169
    // for (let round: uint64 = Txn.lastValid - num - 1; round < Txn.firstValid - 1; round++) {
    intc_1 // 1
    +
    bury 1
    b getBlockTimestamps_while_top@2

getBlockTimestamps_after_while@4:
    // smart_contracts/reti_reader/contract.algo.ts:167
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes 0x151f7c750000000000000000
    log
    intc_1 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getAlgodVersion[routing]() -> void:
getAlgodVersion:
    intc_0 // 0
    // smart_contracts/reti_reader/contract.algo.ts:175
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 8
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    intc_0 // 0

getAlgodVersion_for_header@2:
    // smart_contracts/reti_reader/contract.algo.ts:177
    // for (const poolAppId of poolAppIds) {
    dup
    dig 2
    <
    bz getAlgodVersion_after_for@8
    dig 2
    extract 2 0
    dig 1
    intc_2 // 8
    *
    extract_uint64
    // smart_contracts/reti_reader/contract.algo.ts:178
    // const [algodVer, exists] = op.AppGlobal.getExBytes(poolAppId, Bytes`algodVer`);
    pushbytes "algodVer"
    app_global_get_ex
    swap
    bury 5
    // smart_contracts/reti_reader/contract.algo.ts:179
    // if (exists) {
    bz getAlgodVersion_else_body@5
    // smart_contracts/reti_reader/contract.algo.ts:180
    // log(new arc4.DynamicBytes(algodVer));
    dig 3
    dup
    len
    itob
    extract 6 2
    swap
    concat
    log

getAlgodVersion_after_if_else@6:
    dup
    intc_1 // 1
    +
    bury 1
    b getAlgodVersion_for_header@2

getAlgodVersion_else_body@5:
    // smart_contracts/reti_reader/contract.algo.ts:182
    // log(new arc4.DynamicBytes(Bytes``));
    pushbytes 0x0000
    log
    b getAlgodVersion_after_if_else@6

getAlgodVersion_after_for@8:
    // smart_contracts/reti_reader/contract.algo.ts:175
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes 0x151f7c750000
    log
    intc_1 // 1
    return


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getRemoteValidatorConfig(registryAppId: uint64, validatorId: uint64) -> bytes:
getRemoteValidatorConfig:
    // smart_contracts/reti_reader/contract.algo.ts:33
    // private getRemoteValidatorConfig(registryAppId: uint64, validatorId: uint64): ValidatorConfig {
    proto 2 1
    // smart_contracts/reti_reader/contract.algo.ts:34-37
    // return compileArc4(Reti).call.getValidatorConfig({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    itxn_begin
    // smart_contracts/reti_reader/contract.algo.ts:36
    // args: [validatorId],
    frame_dig -1
    itob
    // smart_contracts/reti_reader/contract.algo.ts:34-37
    // return compileArc4(Reti).call.getValidatorConfig({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    pushbytes 0x75aff61d // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 242 // 242
    ==
    assert // invalid number of bytes for ValidatorConfig
    retsub


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getRemoteValidatorState(registryAppId: uint64, validatorId: uint64) -> bytes:
getRemoteValidatorState:
    // smart_contracts/reti_reader/contract.algo.ts:71
    // private getRemoteValidatorState(registryAppId: uint64, validatorId: uint64): ValidatorCurState {
    proto 2 1
    // smart_contracts/reti_reader/contract.algo.ts:72-75
    // return compileArc4(Reti).call.getValidatorState({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    itxn_begin
    // smart_contracts/reti_reader/contract.algo.ts:74
    // args: [validatorId],
    frame_dig -1
    itob
    // smart_contracts/reti_reader/contract.algo.ts:72-75
    // return compileArc4(Reti).call.getValidatorState({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    pushbytes 0x1f2f0109 // method "getValidatorState(uint64)(uint16,uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 26 // 26
    ==
    assert // invalid number of bytes for ValidatorCurState
    retsub


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getRemotePoolInfo(registryAppId: uint64, validatorId: uint64) -> bytes:
getRemotePoolInfo:
    // smart_contracts/reti_reader/contract.algo.ts:100
    // private getRemotePoolInfo(registryAppId: uint64, validatorId: uint64): PoolInfo[] {
    proto 2 1
    // smart_contracts/reti_reader/contract.algo.ts:101-104
    // return compileArc4(Reti).call.getPools({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    itxn_begin
    // smart_contracts/reti_reader/contract.algo.ts:103
    // args: [validatorId],
    frame_dig -1
    itob
    // smart_contracts/reti_reader/contract.algo.ts:101-104
    // return compileArc4(Reti).call.getPools({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    pushbytes 0x910e94ac // method "getPools(uint64)(uint64,uint16,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 18 // 18
    *
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<PoolInfo>
    retsub


// smart_contracts/reti_reader/contract.algo.ts::RetiReader.getRemoteNodePoolAssignments(registryAppId: uint64, validatorId: uint64) -> bytes:
getRemoteNodePoolAssignments:
    // smart_contracts/reti_reader/contract.algo.ts:126
    // private getRemoteNodePoolAssignments(registryAppId: uint64, validatorId: uint64): NodePoolAssignmentConfig {
    proto 2 1
    // smart_contracts/reti_reader/contract.algo.ts:127-130
    // return compileArc4(Reti).call.getNodePoolAssignments({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    itxn_begin
    // smart_contracts/reti_reader/contract.algo.ts:129
    // args: [validatorId],
    frame_dig -1
    itob
    // smart_contracts/reti_reader/contract.algo.ts:127-130
    // return compileArc4(Reti).call.getNodePoolAssignments({
    //   appId: registryAppId,
    //   args: [validatorId],
    // }).returnValue;
    pushbytes 0x7bbb6c8d // method "getNodePoolAssignments(uint64)((uint64[3])[8])"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 192 // 192
    ==
    assert // invalid number of bytes for NodePoolAssignmentConfig
    retsub
